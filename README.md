# 多线程Logger

## 设计思路

目标：
- 线程安全
- 高性能
- 方便的调用
- 方便的格式化

采用了producer-consumer的模式，在Logger类中开启一个线程从缓冲区读取log向文件中写，其他应用程序线程调用写入接口时只向缓冲区写入log。

logger类和logentry分离，又叫做前后端分离，前者负责将log（string）写入文件中，后者负责格式化制造log和接收用户调用。

## condition_variable的作用

不使用cv的时候，logger直到析构之前其writer线程都会占满CPU（100%），cv的作用是在用户设定条件得不到满足时阻塞一个线程，在本实例中不使用cv阻塞虽然不会产生安全问题（消耗空缓冲区），但仍然会产生额外性能损耗，加入cv后解决了这个问题。

## 单例模式的实现

思路：参考Meyer's Singleton，不需要额外实现单例类或模板类，与现版本代码（ver 0.2）的矛盾点是需要一个无参数的构造函数。然而程序名称，log目录和最大单个log文件大小都是必要信息，如何将其从getInstance的过程中分离出来，并能够令用户能设定并必须设定这两个值呢？

- 配置文件：影响易用性
- 默认值
    - 在构造函数中，仍然需要提供程序名，能自动获取吗？
    - 在getInstance函数中，需要观察：更换参数再次经过static变量声明，是否会产生一个新的对象？用static类变量可解吗？
- 提供单独的set函数：不被调用的话就会一直阻塞writer，可能令用户迷惑

v0.3选择了默认值+set函数

禁用了拷贝构造和赋值构造，并将构造和析构放到private中，使得getInstance成为唯一获取单例的方式。

实现后需要修改test的写法。

## 格式化


### std::format的使用

1. 需要c++20以上，g++在这里使用了版本13
2. format pattern必须是编译时确定的，因此必须是字面量或constexpr函数返回的std::string，后者麻烦且可读性差。



## 宏helpers

目标：创建一个LogEntry，调用其各种方法完成格式化，再调用Logger的单例完成写入。自动包含log来源信息（程序名，函数名，线程id，源码文件名等）

## perfing

### 测时

使用std::chrono的测时更精准，写一个宏来复用计时-调用函数-输出duration的代码。

### 测热点


